"""
`custom_mesh` implements virtual device meshes with better performance than
the default device mesh generated by torch_xla or torchax.
"""

import collections
import dataclasses
from collections.abc import Sequence
from typing import Any

import numpy as np
from torch.utils._pytree import tree_map


def maybe_get_custom_mesh(
  ici_mesh_shape: Sequence[int],
  dcn_mesh_shape: Sequence[int],
  num_devices: int,
  num_slices: int,
) -> np.ndarray | None:
  """
  Get a more performant custom mesh given the mesh shape if applicable.

  The dimensions in mesh shapes should be ordered from least communication intensive
  to most communication intensive.
  """
  non_trivial_ici_mesh_shape = list(ici_mesh_shape)
  while non_trivial_ici_mesh_shape:
    if non_trivial_ici_mesh_shape[-1] == 1:
      non_trivial_ici_mesh_shape.pop()
    else:
      break

  # Pattern matching for 64x4 custom mesh inside a granule.
  # When there exists a 4 chip group that is more communication intensive
  # (e.g. tensor parallelism), we should reshape those groups of 4 devices
  # into a ring to improve collectives performance.
  if (
    len(non_trivial_ici_mesh_shape) >= 2
    and non_trivial_ici_mesh_shape[-1] == 4
    and non_trivial_ici_mesh_shape[-2] == 64
  ):
    return get_64x4_hybrid_ring_mesh(
      ici_mesh_shape=non_trivial_ici_mesh_shape,
      dcn_mesh_shape=dcn_mesh_shape,
      num_devices=num_devices,
      num_slices=num_slices,
    )
  return None


def create_custom_64x4_device_mesh(
  mesh_shape: Sequence[int],
  dcn_mesh_shape: Sequence[int],
  devices: Sequence[Any],
) -> np.ndarray:
  """
  Custom device mesh for 64x4 ICI parallelism.

  Arranges every group of 4 devices into a ring, to improve collectives performance for those groups
  of 4 devices.

  This function is a simplified variation of [1].

  [1]: https://github.com/jax-ml/jax/blame/1079dc4477d41fd25397c8d0b78a32bdc5fa48da/jax/_src/mesh_utils.py#L790
  """

  from jax.experimental import mesh_utils

  assert len(devices) % 256 == 0, (
    f"This custom mesh is not valid for {len(devices)} devices"
  )
  attr = "slice_index"
  if not hasattr(devices[0], attr):
    raise ValueError(
      f"Device {devices[0]} does not have attribute {attr}. See"
      " `process_is_granule` option."
    )
  granule_dict = collections.defaultdict(list)
  for dev in devices:
    granule_dict[getattr(dev, attr)].append(dev)
  granules = [granule_dict[key] for key in sorted(granule_dict.keys())]
  if np.prod(dcn_mesh_shape) != len(granules):
    raise ValueError(
      f"Number of slices {len(granules)} must equal the product of "
      f"dcn_mesh_shape {dcn_mesh_shape}"
    )
  per_granule_meshes = [
    mesh_utils.create_device_mesh(
      [16, 16],
      granule,
      allow_split_physical_axes=False,
    )
    for granule in granules
  ]

  def reshape_mesh_to_rings(a):
    b = []
    for i in range(8):
      b.append([])
      for j in range(8):
        a_i = i * 2
        a_j = j * 2
        # forms a ring of size 4
        b[i].append(
          [
            a[a_i, a_j],
            a[a_i, a_j + 1],
            a[a_i + 1, a_j + 1],
            a[a_i + 1, a_j],
          ]
        )
    b = np.array(b)
    b = np.reshape(b, (64, 4))
    return b

  per_granule_meshes = [
    np.reshape(reshape_mesh_to_rings(x), mesh_shape) for x in per_granule_meshes
  ]
  granule_mesh = np.arange(len(granules)).reshape(dcn_mesh_shape)
  blocks = np.vectorize(lambda i: per_granule_meshes[i], otypes=[object])(granule_mesh)
  device_mesh = np.block(blocks.tolist())
  return device_mesh


@dataclasses.dataclass
class Device:
  process_index: int
  slice_index: int
  uid: int
  device_kind: str = ""
  platform: str = "cpu"


def get_64x4_hybrid_ring_mesh(
  ici_mesh_shape: Sequence[int],
  dcn_mesh_shape: Sequence[int],
  num_devices: int,
  num_slices: int,
) -> np.ndarray:
  num_devices_per_granule = num_devices // num_slices
  devices = [
    Device(i // num_devices_per_granule, i // num_devices_per_granule, i)
    for i in range(num_devices)
  ]
  devices = (
    create_custom_64x4_device_mesh(ici_mesh_shape, dcn_mesh_shape, devices)
    .reshape(-1)
    .tolist()
  )
  devices = np.array(tree_map(lambda d: d.uid, devices))
  return devices
